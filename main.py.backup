#!/usr/bin/env python3
"""
AIDAN Brain API — AI Memory & Knowledge Search as a Service
Exposes brain database queries and ChromaDB semantic search via REST API.
Rate-limited: free tier (100 req/day), paid tier (unlimited).
"""

import json
import os
import sqlite3
import time
from collections import defaultdict
from typing import Optional

from fastapi import FastAPI, HTTPException, Header, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from pydantic import BaseModel, Field

BRAIN_DB = os.path.expanduser("~/clawd/data/aidan_brain.db")
CHROMA_PATH = os.path.expanduser("~/Desktop/aidan/data/chromadb")

# API keys — in production, move to env/secrets
API_KEYS = {
    "demo-free-key": {"tier": "free", "name": "Demo User"},
    # Add paid keys here: "sk-paid-xxx": {"tier": "paid", "name": "Customer"}
}

# Rate limiting: {api_key: {date: count}}
rate_limits = defaultdict(lambda: defaultdict(int))
RATE_LIMITS = {"free": 100, "paid": 10000}

app = FastAPI(
    title="AIDAN Brain API",
    description="AI-powered memory and knowledge search. Query structured brain data or perform semantic search across vector memory.",
    version="0.1.0",
    docs_url="/docs",
    redoc_url="/redoc",
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["GET", "POST"],
    allow_headers=["*"],
)


def check_rate_limit(api_key: str, tier: str) -> bool:
    today = time.strftime("%Y-%m-%d")
    count = rate_limits[api_key][today]
    limit = RATE_LIMITS.get(tier, 100)
    if count >= limit:
        return False
    rate_limits[api_key][today] += 1
    return True


def get_auth(x_api_key: Optional[str]) -> dict:
    if not x_api_key:
        raise HTTPException(status_code=401, detail="Missing X-API-Key header")
    info = API_KEYS.get(x_api_key)
    if not info:
        raise HTTPException(status_code=403, detail="Invalid API key")
    if not check_rate_limit(x_api_key, info["tier"]):
        raise HTTPException(status_code=429, detail=f"Rate limit exceeded ({RATE_LIMITS[info['tier']]} req/day)")
    return info


def get_db():
    conn = sqlite3.connect(BRAIN_DB)
    conn.row_factory = sqlite3.Row
    return conn


# --- ChromaDB lazy init ---
_chroma_client = None

def get_chroma():
    global _chroma_client
    if _chroma_client is None:
        try:
            import chromadb
            _chroma_client = chromadb.PersistentClient(path=CHROMA_PATH)
        except Exception:
            return None
    return _chroma_client


# --- Models ---
class SearchRequest(BaseModel):
    query: str = Field(..., min_length=1, max_length=500, description="Search query text")
    collection: str = Field("aidan_memory", description="ChromaDB collection to search")
    limit: int = Field(5, ge=1, le=20, description="Number of results")


class BrainQueryRequest(BaseModel):
    query_type: str = Field(..., description="Type: goals, learnings, procedures, metrics, tasks, self_model")
    limit: int = Field(10, ge=1, le=50)
    status_filter: Optional[str] = Field(None, description="Filter by status (e.g., 'active', 'completed')")


# --- Endpoints ---

@app.get("/")
async def root():
    return {
        "service": "AIDAN Brain API",
        "version": "0.1.0",
        "docs": "/docs",
        "endpoints": {
            "GET /health": "Service health check",
            "GET /brain/status": "Brain database overview",
            "POST /brain/query": "Query structured brain data",
            "POST /search": "Semantic search across vector memory",
            "GET /brain/goals": "List active goals",
            "GET /brain/learnings": "Recent learnings",
        },
    }


@app.get("/health")
async def health():
    db_ok = os.path.exists(BRAIN_DB)
    chroma_ok = get_chroma() is not None
    return {
        "status": "healthy" if db_ok else "degraded",
        "brain_db": db_ok,
        "chromadb": chroma_ok,
    }


@app.get("/brain/status")
async def brain_status(x_api_key: Optional[str] = Header(None)):
    auth = get_auth(x_api_key)
    conn = get_db()
    try:
        goals = conn.execute("SELECT COUNT(*) FROM goals WHERE status='active'").fetchone()[0]
        learnings = conn.execute("SELECT COUNT(*) FROM learning_log").fetchone()[0]
        procedures = conn.execute("SELECT COUNT(*) FROM procedures").fetchone()[0]
        tasks_total = conn.execute("SELECT COUNT(*) FROM tasks").fetchone()[0]
        top_goal = conn.execute(
            "SELECT title, progress_pct FROM goals WHERE status='active' ORDER BY priority DESC LIMIT 1"
        ).fetchone()
    finally:
        conn.close()

    chroma_count = 0
    client = get_chroma()
    if client:
        try:
            chroma_count = sum(c.count() for c in client.list_collections())
        except Exception:
            pass

    return {
        "active_goals": goals,
        "total_learnings": learnings,
        "procedures": procedures,
        "tasks": tasks_total,
        "top_goal": {"title": top_goal[0], "progress": top_goal[1]} if top_goal else None,
        "vector_memory_entries": chroma_count,
        "tier": auth["tier"],
    }


@app.get("/brain/goals")
async def brain_goals(x_api_key: Optional[str] = Header(None)):
    auth = get_auth(x_api_key)
    conn = get_db()
    try:
        rows = conn.execute(
            "SELECT id, title, priority, progress_pct, status, category FROM goals ORDER BY priority DESC"
        ).fetchall()
    finally:
        conn.close()
    return {"goals": [dict(r) for r in rows]}


@app.get("/brain/learnings")
async def brain_learnings(
    limit: int = 10,
    category: Optional[str] = None,
    x_api_key: Optional[str] = Header(None),
):
    auth = get_auth(x_api_key)
    conn = get_db()
    try:
        if category:
            rows = conn.execute(
                "SELECT id, source, lesson, category, confidence, created_at FROM learning_log WHERE category=? ORDER BY created_at DESC LIMIT ?",
                (category, min(limit, 50)),
            ).fetchall()
        else:
            rows = conn.execute(
                "SELECT id, source, lesson, category, confidence, created_at FROM learning_log ORDER BY created_at DESC LIMIT ?",
                (min(limit, 50),),
            ).fetchall()
    finally:
        conn.close()
    return {"learnings": [dict(r) for r in rows], "count": len(rows)}


@app.post("/brain/query")
async def brain_query(req: BrainQueryRequest, x_api_key: Optional[str] = Header(None)):
    auth = get_auth(x_api_key)

    tables = {
        "goals": ("goals", "id, title, priority, progress_pct, status, category", "priority DESC"),
        "learnings": ("learning_log", "id, source, lesson, category, confidence, created_at", "created_at DESC"),
        "procedures": ("procedures", "id, task_type, strategy, tools_sequence, created_at", "created_at DESC"),
        "metrics": ("metrics", "date, tasks_completed, tasks_failed, exec_allowed, exec_blocked", "date DESC"),
        "tasks": ("tasks", "id, goal_id, description, status, priority, result, created_at", "created_at DESC"),
        "self_model": ("self_model", "attribute, value, confidence", "attribute"),
    }

    if req.query_type not in tables:
        raise HTTPException(status_code=400, detail=f"Invalid query_type. Use: {list(tables.keys())}")

    table, cols, order = tables[req.query_type]
    sql = f"SELECT {cols} FROM {table}"
    params = []

    if req.status_filter:
        sql += " WHERE status = ?"
        params.append(req.status_filter)

    sql += f" ORDER BY {order} LIMIT ?"
    params.append(req.limit)

    conn = get_db()
    try:
        rows = conn.execute(sql, params).fetchall()
    finally:
        conn.close()

    return {"query_type": req.query_type, "count": len(rows), "results": [dict(r) for r in rows]}


@app.post("/search")
async def semantic_search(req: SearchRequest, x_api_key: Optional[str] = Header(None)):
    auth = get_auth(x_api_key)

    client = get_chroma()
    if not client:
        raise HTTPException(status_code=503, detail="ChromaDB not available")

    valid_collections = ["aidan_memory", "aidan_procedures", "aidan_reflections"]
    if req.collection not in valid_collections:
        raise HTTPException(status_code=400, detail=f"Invalid collection. Use: {valid_collections}")

    try:
        collection = client.get_collection(req.collection)
        results = collection.query(query_texts=[req.query], n_results=req.limit)
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

    items = []
    if results["documents"] and results["documents"][0]:
        for doc, meta, dist in zip(
            results["documents"][0],
            results["metadatas"][0] if results["metadatas"] else [{}] * len(results["documents"][0]),
            results["distances"][0] if results["distances"] else [0] * len(results["documents"][0]),
        ):
            items.append({"document": doc, "metadata": meta, "distance": dist})

    return {
        "collection": req.collection,
        "query": req.query,
        "count": len(items),
        "results": items,
    }


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="127.0.0.1", port=8100, log_level="info")
